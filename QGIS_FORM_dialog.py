# -*- coding: utf-8 -*-
"""
/***************************************************************************
 QgisFORMDialog
                                 A QGIS plugin
 This is a plugin for landslide susceptibility assessments using the First Order Reliability Method (FORM)
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-05-14
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Bin Tong (HHU)
        email                : bin_tong12@hhu.edu.cn
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

from qgis.PyQt import uic
from qgis.PyQt import QtWidgets

from qgis.PyQt.QtWidgets import QAction, QFileDialog
from qgis.utils import iface
from osgeo import gdal, gdalconst
import math
import scipy.stats as stats
import time
import numpy as np
import scipy as sc

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'QGIS_FORM_dialog_base.ui'))


class QgisFORMDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        """Constructor."""
        super(QgisFORMDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)
        self.pushButton_HLRF_maerkang.clicked.connect(self.HLRF_FORM_maerkang)

        # ------QGIS_FORM-----UI------
        self.doubleSpinBox_4.setRange(-9999.0, 9999.0)
        self.doubleSpinBox.setRange(-9999.0, 9999.0)
        self.doubleSpinBox_2.setRange(-9999.0, 9999.0)
        self.doubleSpinBox_3.setRange(-9999.0, 9999.0)
        self.doubleSpinBox_5.setRange(-9999.0, 9999.0)
        self.doubleSpinBox_8.setRange(-9999.0, 9999.0)
        self.doubleSpinBox_9.setRange(-9999.0, 9999.0)
        self.doubleSpinBox_17.setRange(-9999.0, 9999.0)
        self.doubleSpinBox_16.setRange(-9999.0, 9999.0)
        self.doubleSpinBox_15.setRange(-9999.0, 9999.0)
        self.doubleSpinBox_14.setRange(-9999.0, 9999.0)
        self.doubleSpinBox_13.setRange(-9999.0, 9999.0)
        self.doubleSpinBox_12.setRange(-9999.0, 9999.0)
        self.doubleSpinBox_11.setRange(-9999.0, 9999.0)
        self.doubleSpinBox_10.setRange(-9999.0, 9999.0)
        self.doubleSpinBox_18.setRange(-9999.0, 9999.0)
        self.doubleSpinBox_21.setRange(-9999.0, 9999.0)
        self.doubleSpinBox_19.setRange(-9999.0, 9999.0)
        self.doubleSpinBox_20.setRange(-9999.0, 9999.0)
        self.doubleSpinBox_22.setRange(-9999.0, 9999.0)

        self.pushButton.clicked.connect(self.select_output_file_pf)
        self.pushButton_2.clicked.connect(self.select_output_file_beta)
        self.pushButton_3.clicked.connect(self.select_output_file_FOS)
        self.pushButton_4.clicked.connect(self.select_output_file_ky)

        self.filename_pf = ""
        self.filename_beta = ""
        self.filename_FOS = ""
        self.filename_ky = ""

        self.comboBox_phi.addItems(['NORMAL', 'LOGNORMAL', 'EXTVALUE1', 'EXPONENTIAL', 'GAMMA', 'WEIBULL'])
        self.comboBox_c.addItems(['NORMAL', 'LOGNORMAL', 'EXTVALUE1', 'EXPONENTIAL', 'GAMMA', 'WEIBULL'])
        self.comboBox_suw.addItems(['NORMAL', 'LOGNORMAL', 'EXTVALUE1', 'EXPONENTIAL', 'GAMMA', 'WEIBULL'])

    def select_output_file_pf(self):
        filename_pf, _filter = QFileDialog.getSaveFileName(self, "Select output file", "", "*.tif")
        self.filename_pf = filename_pf
        self.lineEdit.setText(filename_pf)

    def select_output_file_beta(self):
        filename_beta, _filter = QFileDialog.getSaveFileName(self, "Select output file", "", "*.tif")
        self.filename_beta = filename_beta
        self.lineEdit_2.setText(filename_beta)

    def select_output_file_FOS(self):
        filename_FOS, _filter = QFileDialog.getSaveFileName(self, "Select output file", "", "*.tif")
        self.filename_FOS = filename_FOS
        self.lineEdit_3.setText(filename_FOS)

    def select_output_file_ky(self):
        filename_ky, _filter = QFileDialog.getSaveFileName(self, "Select output file", "", "*.tif")
        self.filename_ky = filename_ky
        self.lineEdit_4.setText(filename_ky)

    def HLRF_FORM_maerkang(self):

        def raster_array_SE(img_path, process):
            rlayer = iface.addRasterLayer(img_path, "QGIS-FORM raster file", "gdal")

            if rlayer.isValid():
                print("This is a valid raster layer!")
            else:
                print("This raster layer is invalid!")

            stats_ = rlayer.dataProvider().bandStatistics(1)
            dataset_ = gdal.Open(img_path, gdalconst.GA_ReadOnly)
            img_width_ = dataset_.RasterXSize
            img_height_ = dataset_.RasterYSize
            arr = np.array(dataset_.ReadAsArray(0, 0, img_width_, img_height_),
                           dtype=float)

            if process == 1:
                arr[np.isnan(arr)] = stats_.mean
                arr[arr > stats_.maximumValue] = stats_.mean
                arr[arr < stats_.minimumValue] = stats_.mean

            return arr


        # -----------------------phi_stat1-----------
        img_path_phi1 = self.mQgsFileWidget.filePath()
        if self.checkBox.isChecked():
            phi_arr = raster_array_SE(img_path_phi1, 1)
        else:
            phi_arr = raster_array_SE(img_path_phi1, 0)
        phi_rad_arr = phi_arr * np.pi / 180

        # ----------------------phi_stat2------
        img_path_phi2 = self.mQgsFileWidget_2.filePath()
        if self.checkBox_2.isChecked():
            phi_stat2_arr = raster_array_SE(img_path_phi2, 1)
        else:
            phi_stat2_arr = raster_array_SE(img_path_phi2, 0)
        phi_stat2_rad_arr = phi_stat2_arr * np.pi / 180

        # ----------------------c_stat1------
        img_path_c1 = self.mQgsFileWidget_3.filePath()
        if self.checkBox_3.isChecked():
            c_arr = raster_array_SE(img_path_c1, 1)
        else:
            c_arr = raster_array_SE(img_path_c1, 0)

        # --------------------c_stat2----
        img_path_c2 = self.mQgsFileWidget_4.filePath()
        if self.checkBox_4.isChecked():
            c_arr_stat2 = raster_array_SE(img_path_c2, 1)
        else:
            c_arr_stat2 = raster_array_SE(img_path_c2, 0)

        # ----------------------suw_stat1---
        img_path_suw1 = self.mQgsFileWidget_6.filePath()
        if self.checkBox_6.isChecked():
            suw_arr = raster_array_SE(img_path_suw1, 1)
        else:
            suw_arr = raster_array_SE(img_path_suw1, 0)

        # -----------------------suw_stat2---
        img_path_suw2 = self.mQgsFileWidget_5.filePath()
        if self.checkBox_5.isChecked():
            suw_arr_stat2 = raster_array_SE(img_path_suw2, 1)
        else:
            suw_arr_stat2 = raster_array_SE(img_path_suw2, 0)

        # ---------------------------D---
        img_path_D = self.mQgsFileWidget_7.filePath()
        if self.checkBox_7.isChecked():
            D_arr = raster_array_SE(img_path_D, 1)
        else:
            D_arr = raster_array_SE(img_path_D, 0)

        # ------------------slope---
        img_path_slope = self.mQgsFileWidget_8.filePath()
        if self.checkBox_8.isChecked():
            slope_arr = raster_array_SE(img_path_slope, 1)
        else:
            slope_arr = raster_array_SE(img_path_slope, 0)
        slope_rad_arr = slope_arr * np.pi / 180

        # ------------------Seismic source---
        img_path_SS = self.mQgsFileWidget_9.filePath()
        if self.checkBox_9.isChecked():
            PGA59_source_arr = raster_array_SE(img_path_SS, 1)
        else:
            PGA59_source_arr = raster_array_SE(img_path_SS, 0)


        # -------------------------------Pseudo-static method------------------------------
        # Seismic source=9
        row_indices, col_indices = np.where(PGA59_source_arr == 9)
        target_row = np.min(row_indices)
        target_col = np.min(col_indices[row_indices == target_row])
        positions = np.indices(PGA59_source_arr.shape) - np.array([target_row, target_col])[:, np.newaxis, np.newaxis]
        vertical, horizonatal = positions
        distance = np.sqrt(vertical ** 2 + horizonatal ** 2) * 30 / 1000  # km 一个栅格：30m,震源深度7km
        distance_ShiJi = np.sqrt(distance ** 2 + 7 ** 2)

        # Seismic parameter
        H = 2.5  # m
        Vs = 300  # m/s
        Ts = 4 * H / Vs
        M = 6
        Rrup = distance
        PGA = 0.2

        # Sa
        PGA_1 = PGA

        c1 = self.doubleSpinBox_8.value()
        c4 = self.doubleSpinBox_9.value()
        c5 = self.doubleSpinBox_17.value()

        a1 = self.doubleSpinBox_16.value()
        a2 = self.doubleSpinBox_15.value()
        a3 = self.doubleSpinBox_14.value()
        a4 = self.doubleSpinBox_13.value()
        a5 = self.doubleSpinBox_12.value()
        a6 = self.doubleSpinBox_11.value()
        a9 = self.doubleSpinBox_10.value()
        a10 = self.doubleSpinBox_18.value()
        a11 = self.doubleSpinBox_21.value()
        a12 = self.doubleSpinBox_19.value()
        a13 = self.doubleSpinBox_20.value()

        n = self.doubleSpinBox_22.value()

        F = self.doubleSpinBox_5.value()  # fault type (1 for reverse, 0.5 for reverse/oblique, and 0 otherwise)
        HW = self.spinBox_4.value()  # hanging wall sites (1 for sites over the hanging wall, 0 otherwise),
        S = self.spinBox_2.value()  # site class (0 for rock or shallow soil, 1 for deep soil).

        R = np.sqrt(Rrup ** 2 + c4 ** 2)

        if M > c1:
            f1 = a1 + a4 * (M - c1) + a12 * (8.5 - M) ** n + (a3 + a13 * (M - c1)) * np.log(R)
        else:
            f1 = a1 + a2 * (M - c1) + a12 * (8.5 - M) ** n + (a3 + a13 * (M - c1)) * np.log(R)

        if M <= 5.8:
            f3 = a5
        elif M >= c1:
            f3 = a6
        else:
            f3 = a5 + (a6 - a5) / (c1 - 5.8)

        if M <= 5.5:
            fHWm = 0
        elif M >= 6.5:
            fHWm = 1
        else:
            fHWm = M - 5.5

        if ((0 < Rrup) & (Rrup <= 4)).any():
            fHWr = 0
        elif ((4 < Rrup) & (Rrup <= 8)).any():
            fHWr = a9 * (Rrup - 4) / 4
        elif ((8 < Rrup) & (Rrup <= 18)).any():
            fHWr = a9
        elif ((18 < Rrup) & (Rrup < 24)).any():
            fHWr = a9 * (1 - (Rrup - 18) / 7)
        else:
            fHWr = 0

        f4 = fHWm * fHWr

        f5 = a10 + a11 * math.log(PGA_1 + c5)

        LnSa = f1 + F * f3 + HW * f4 + S * f5

        Sa = np.exp(LnSa) * 1.25

        Da = self.doubleSpinBox_2.value()  # cm

        Sa_1 = Sa

        normal_dist = stats.norm(loc=0, scale=0.66)

        ε = normal_dist.ppf(1 - self.doubleSpinBox_3.value())

        a = 2.83 - 0.566 * np.log(Sa_1)

        if Ts < 0.05:
            b = a ** 2 - 1.33 * (
                    np.log(Da) + 0.22 - 3.04 * np.log(Sa_1) + 0.244 * (np.log(Sa_1)) ** 2 - 1.5 * Ts - 0.278 * (
                    M - 7) - ε)
        else:
            b = a ** 2 - 1.33 * (
                    np.log(Da) + 1.1 - 3.04 * np.log(Sa_1) + 0.244 * (np.log(Sa_1)) ** 2 - 1.5 * Ts - 0.278 * (
                    M - 7) - ε)

        k = np.exp((-a + np.sqrt(b)) / 0.665) * (distance / distance_ShiJi)


        start_time = time.time()

        def EqvTransform(x, CDF, PDF, code):
            Delt = 1e-16
            if CDF < Delt:
                CDF = Delt
            elif CDF > 1 - Delt:
                CDF = 1 - Delt

            EqvSigma_prop = sc.stats.norm.ppf(
                CDF)
            EqvSigma = sc.stats.norm.pdf(EqvSigma_prop, 0, 1) / PDF

            if code == 1:
                Eq_result = x - EqvSigma * sc.stats.norm.ppf(CDF)
            elif code == 2:
                Eq_result = EqvSigma
            else:
                print("Incorrect")

            return Eq_result


        def EqvN(DistributionName, paralist, x, code):
            delt = 0.0001

            para1 = paralist[0]
            para2 = paralist[1]

            if DistributionName == 1:  # "NORMAL"
                if code == 1:
                    result = para1
                elif code == 2:
                    result = para2
                else:
                    print("code is incorrect")

            elif DistributionName == 2:  # "LOGNORMAL"
                if x < delt:
                    x = delt
                Lambda = np.log(para1) - 0.5 * np.log(1 + (para2 / para1) ** 2)
                if code == 1:
                    result = x * (1 - np.log(x) + Lambda)
                elif code == 2:
                    result = x * np.sqrt(np.log(1 + (para2 / para1) ** 2))
                else:
                    print("code is incorrect")

            elif DistributionName == 3:  # "EXTVALUE1"（Generalized Extreme Value distribution Type-I）
                alfa = 1.2825498302 / para2
                u = para1 - 0.5772 / alfa
                CDF = np.exp(-np.exp(-alfa * (x - u)))
                PDF = alfa * np.exp(-alfa * (x - u)) * CDF
                result = EqvTransform(x, CDF, PDF, code)

            elif DistributionName == 4:  # "EXPONENTIAL"
                b = para1
                if x < delt:
                    x = delt
                CDF = 1 - np.exp(-x / b)
                PDF = 1 / b * np.exp(-x / b)
                result = EqvTransform(x, CDF, PDF, code)

            elif DistributionName == 6:  # "GAMMA"
                if x < delt:
                    x = delt
                CDF = sc.stats.gamma.cdf(x, para1, loc=0,
                                         scale=para2)
                PDF = sc.stats.gamma.pdf(x, para1, loc=0, scale=para2)
                result = EqvTransform(x, CDF, PDF, code)

            elif DistributionName == 7:  # "WEIBULL"
                if x < delt:
                    x = delt
                CDF = sc.stats.exponweib.cdf(x, para1, para2)
                PDF = sc.stats.exponweib.pdf(x, para1, para2)
                result = EqvTransform(x, CDF, PDF, code)

            return result


        beta_all = np.full_like(slope_arr, 0, dtype=float)
        Pf_all = np.full_like(slope_arr, 0, dtype=float)

        FOS = (c_arr + suw_arr * D_arr * (np.cos(slope_rad_arr) - k * np.sin(slope_rad_arr)) * np.cos(
            slope_rad_arr) * np.tan(phi_rad_arr)) / (
                          suw_arr * D_arr * (np.sin(slope_rad_arr) + k * np.cos(slope_rad_arr)) * np.cos(slope_rad_arr))

        current_text_phi = self.comboBox_phi.currentText()
        current_text_c = self.comboBox_c.currentText()
        current_text_suw = self.comboBox_suw.currentText()

        if current_text_phi == 'NORMAL':
            a_phi = 1
        elif current_text_phi == 'LOGNORMAL':
            a_phi = 2
        elif current_text_phi == 'EXTVALUE1':
            a_phi = 3
        elif current_text_phi == 'EXPONENTIAL':
            a_phi = 4
        elif current_text_phi == 'GAMMA':
            a_phi = 6
        elif current_text_phi == 'WEIBULL':
            a_phi = 7

        if current_text_c == 'NORMAL':
            a_c = 1
        elif current_text_c == 'LOGNORMAL':
            a_c = 2
        elif current_text_c == 'EXTVALUE1':
            a_c = 3
        elif current_text_c == 'EXPONENTIAL':
            a_c = 4
        elif current_text_c == 'GAMMA':
            a_c = 6
        elif current_text_c == 'WEIBULL':
            a_c = 7

        if current_text_suw == 'NORMAL':
            a_suw = 1
        elif current_text_suw == 'LOGNORMAL':
            a_suw = 2
        elif current_text_suw == 'EXTVALUE1':
            a_suw = 3
        elif current_text_suw == 'EXPONENTIAL':
            a_suw = 4
        elif current_text_suw == 'GAMMA':
            a_suw = 6
        elif current_text_suw == 'WEIBULL':
            a_suw = 7


        print("-------------Start regional landslide calculation---------------")

        for i in range(len(slope_arr)):
            for j in range(len(slope_arr[i])):
                array1_value = np.array([c_arr[i][j], c_arr_stat2[i][j]])
                array2_value = np.array([phi_rad_arr[i][j], phi_stat2_rad_arr[i][j]])
                array3_value = np.array([suw_arr[i][j], suw_arr_stat2[i][j]])

                x_initial = np.array([[c_arr[i][j]],
                                      [phi_rad_arr[i][j]],
                                      [suw_arr[i][j]]])

                k_90 = k[i][j]

                D_90 = D_arr[i][j]

                slope_rad_90 = slope_rad_arr[i][j]

                slope_rad_ij_0 = np.array([[1e+8]])

                R = np.array([[1, 0, 0],
                              [0, 1, 0],
                              [0, 0, 1]])

                inv_R = np.linalg.inv(R)

                constraint1 = np.array([[self.doubleSpinBox_23.value()]])

                u = 0
                uu = self.spinBox.value()
                while u <= uu:

                    if u == 0:
                        x_k = x_initial
                        x_k0 = x_initial
                    else:
                        x_k0 = x_k

                    u += 1

                    d_array1 = 1 / (x_k0[2][0] * D_90 * (np.sin(slope_rad_90) + k_90 * np.cos(slope_rad_90)))
                    d_array2 = (1 + (np.tan(x_k0[1][0])) ** 2) * (
                                np.cos(slope_rad_90) - k_90 * np.sin(slope_rad_90)) / (
                                           np.sin(slope_rad_90) + k_90 * np.cos(slope_rad_90))
                    d_array3 = -x_k0[0][0] / (
                                D_90 * np.cos(slope_rad_90) * (np.sin(slope_rad_90) + k_90 * np.cos(slope_rad_90)) * (
                        x_k0[2][0]) ** 2)

                    grad_g_x = np.array([[d_array1],
                                         [d_array2],
                                         [d_array3]])

                    del d_array1, d_array2, d_array3

                    mu_x_k_y = EqvN(a_c, array1_value, x_k0[0][0], 1)
                    mu_x_k_z = EqvN(a_phi, array2_value, x_k0[1][0], 1)
                    mu_x_k_m = EqvN(a_suw, array3_value, x_k0[2][0], 1)

                    mu_x_k = np.concatenate((np.array([[mu_x_k_y]]), np.array([[mu_x_k_z]]), np.array([[mu_x_k_m]])))

                    del mu_x_k_y, mu_x_k_z, mu_x_k_m

                    sigma_i_n_y = EqvN(a_c, array1_value, x_k0[0][0], 2)
                    sigma_i_n_z = EqvN(a_phi, array2_value, x_k0[1][0], 2)
                    sigma_i_n_m = EqvN(a_suw, array3_value, x_k0[2][0], 2)

                    sigma_i_n = np.concatenate(
                        (np.array([[sigma_i_n_y]]), np.array([[sigma_i_n_z]]), np.array([[sigma_i_n_m]])))

                    sigma_k_n = np.array([[sigma_i_n_y, 0, 0],
                                          [0, sigma_i_n_z, 0],
                                          [0, 0, sigma_i_n_m]])

                    T_k = np.dot(np.dot(sigma_k_n.transpose(), R), sigma_k_n)

                    del sigma_i_n_y, sigma_i_n_z, sigma_i_n_m, sigma_k_n

                    slope_rad_ij = np.sqrt(
                        np.dot(np.dot(((x_k - mu_x_k) / sigma_i_n).transpose(), inv_R), (x_k - mu_x_k) / sigma_i_n))

                    x_k = mu_x_k + 1 / (np.dot(np.dot(grad_g_x.transpose(), T_k), grad_g_x)) * (
                            np.dot(grad_g_x.transpose(), (x_k - mu_x_k)) - ((x_k[0][0] + x_k[2][0] * D_arr[i][j] * (
                                np.cos(slope_rad_arr[i][j]) - k[i][j] * np.sin(slope_rad_arr[i][j])) * np.cos(
                        slope_rad_arr[i][j]) * np.tan(x_k[1][0])) / (x_k[2][0] * D_arr[i][j] * (
                                np.sin(slope_rad_arr[i][j]) + k[i][j] * np.cos(slope_rad_arr[i][j])) * np.cos(
                        slope_rad_arr[i][j])) - 1)) * np.dot(T_k, grad_g_x)

                    slope_rad_ij_constraint1 = abs(slope_rad_ij - slope_rad_ij_0)

                    slope_rad_ij_0 = slope_rad_ij

                    FOS_end = (x_k[0][0] + x_k[2][0] * D_90 * (
                                np.cos(slope_rad_arr[i][j]) - k[i][j] * np.sin(slope_rad_arr[i][j])) * np.cos(
                        slope_rad_arr[i][j]) * np.tan(x_k[1][0])) / (
                                      x_k[2][0] * D_90 * (
                                          np.sin(slope_rad_arr[i][j]) + k[i][j] * np.cos(slope_rad_arr[i][j])) * np.cos(
                                  slope_rad_arr[i][j])) - 1

                    if (np.count_nonzero(slope_rad_ij_constraint1 >= constraint1) == 0 and abs(
                            FOS_end <= 0.05)) or u == uu:
                        if FOS[i][j] > 1:
                            beta_all[i][j] = slope_rad_ij
                            Pf_all[i][j] = sc.stats.norm.cdf(- slope_rad_ij)

                        if FOS[i][j] == 1:
                            beta_all[i][j] = 0
                            Pf_all[i][j] = sc.stats.norm.cdf(0)

                        if FOS[i][j] < 1:
                            beta_all[i][j] = -slope_rad_ij
                            Pf_all[i][j] = sc.stats.norm.cdf(slope_rad_ij)

                        break

                    del x_k0, grad_g_x, mu_x_k, sigma_i_n, T_k, slope_rad_ij, slope_rad_ij_constraint1, FOS_end,

                del array1_value, array2_value, array3_value, x_initial, u, uu, D_90, slope_rad_90, slope_rad_ij_0, x_k, R, inv_R, constraint1

        del phi_arr, phi_rad_arr, phi_stat2_arr, phi_stat2_rad_arr, c_arr, c_arr_stat2, suw_arr, suw_arr_stat2, D_arr, slope_arr, slope_rad_arr

        end_time = time.time()
        elapsed_time = end_time - start_time
        print("Program run time：", elapsed_time, "seconds")

        def numpyToRaster(refRaster_path, ShuZu, Raster_save):
            dataset_phi = gdal.Open(refRaster_path, gdalconst.GA_ReadOnly)
            img_width = dataset_phi.RasterXSize
            img_height = dataset_phi.RasterYSize
            adf_GeoTransform = dataset_phi.GetGeoTransform()
            im_Proj = dataset_phi.GetProjection()
            arr = ShuZu

            # TIF
            driver = gdal.GetDriverByName("GTiff")
            datasetnew = driver.Create(Raster_save, img_width, img_height, 1, gdal.GDT_Float32)
            datasetnew.SetGeoTransform(adf_GeoTransform)
            datasetnew.SetProjection(im_Proj)
            band = datasetnew.GetRasterBand(1)
            band.WriteArray(arr)
            datasetnew.FlushCache()

        refRaster_path = self.mQgsFileWidget_8.filePath()

        Raster_save1 = self.filename_pf
        numpyToRaster(refRaster_path, Pf_all, Raster_save1)

        Raster_save2 = self.filename_beta
        numpyToRaster(refRaster_path, beta_all, Raster_save2)

        Raster_save3 = self.filename_FOS
        numpyToRaster(refRaster_path, FOS, Raster_save3)

        Raster_save4 = self.filename_ky
        numpyToRaster(refRaster_path, k, Raster_save4)

        del beta_all, Pf_all, FOS, k

        self.label_19.setText("<html><head/><body><p>Calculation complete, file saved!<br/>Computing time（s）: {}".format(elapsed_time))